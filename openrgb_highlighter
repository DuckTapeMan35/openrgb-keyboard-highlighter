#!/root/openrgb_keyboard_highlighter_venv/bin/python
import logging
from openrgb import OpenRGBClient
from openrgb.utils import RGBColor, DeviceType
import threading
import time
import yaml
import os
import re
import traceback
import json
from collections import deque
from typing import Dict, List, Tuple, Any
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
import subprocess
import select
import socket
import sys
import keyboard
import pwd

# Conditionally import i3ipc only if needed
try:
    import i3ipc
    I3_AVAILABLE = True
except ImportError:
    I3_AVAILABLE = False

# Create a memory-efficient logger formatter
class MemoryEfficientFormatter(logging.Formatter):
    def format(self, record):
        # Use a simpler format for most messages
        if record.levelno <= logging.INFO:
            return f"{record.getMessage()}"
        else:
            # More detailed format for warnings and errors
            return f"{record.name} - {record.levelname} - {record.getMessage()}"

# Get the correct user home directory
def get_user_home():
    """Get the home directory of the logged-in user, even when running as root."""
    try:
        # Try to get the user from environment variables (works with sudo)
        username = os.environ.get('OPENRGB_USER')
        if not username:
            # Try other common environment variables
            username = os.environ.get('LOGNAME') or os.environ.get('USER')
        
        # If we found a username and it's not root, get their home directory
        if username and username != 'root':
            return pwd.getpwnam(username).pw_dir
        
        # Final fallback: Use current user's home
        return os.path.expanduser('~')
    except Exception as e:
        logging.error(f"Error determining user home: {e}")
        return os.path.expanduser('~')  # Fallback

# Update your setup_logger function
def setup_logger(level=logging.INFO):
    # Get the correct user home directory
    user_home = get_user_home()
    # Create log directory if it doesn't exist
    log_dir = os.path.join(user_home, '.config', 'openrgb-keyboard-highlighter')
    os.makedirs(log_dir, exist_ok=True)
    log_file = os.path.join(log_dir, 'logs.txt')
    
    logger = logging.getLogger('openrgb_keyboard_highlighter')
    logger.setLevel(level)
    
    # Create memory-efficient formatter
    formatter = MemoryEfficientFormatter('%(asctime)s - %(message)s')
    
    # Create file handler
    fh = logging.FileHandler(log_file)
    fh.setLevel(level)
    fh.setFormatter(formatter)
    
    # Create console handler
    ch = logging.StreamHandler()
    ch.setLevel(level)
    ch.setFormatter(formatter)
    
    # Add handlers to logger
    logger.addHandler(fh)
    logger.addHandler(ch)
    
    return logger

# Initialize with default level, will be updated after config load
logger = setup_logger()

class PywalFileHandler(FileSystemEventHandler):
    """Handles pywal color file changes"""
    def __init__(self, callback):
        super().__init__()
        self.callback = callback
    
    def on_modified(self, event):
        if event.src_path.endswith('colors'):
            self.callback()

class ConfigFileHandler(FileSystemEventHandler):
    """Handles config file changes"""
    def __init__(self, callback):
        super().__init__()
        self.callback = callback
    
    def on_modified(self, event):
        if event.src_path.endswith('config.yaml'):
            self.callback()

class KeyboardController:
    __slots__ = [
        'config', 'client', 'openrgb_keyboard', 'matrix_zone', 'matrix_map_dict', 'rows', 'cols',
        'key_positions', 'wm_type', 'pressed_keys', 'colors_lock',
        'colors', 'key_listener', 'wm_thread', 'pywal_updated',
        'config_updated', 'pywal_watchdog_observer', 'config_watchdog_observer',
        'current_mode', 'modifier_keys', 'current_key_states', 'need_redraw', 'last_non_empty_workspaces',
        'redraw_count', 'skip_count', '_string_cache', 'previous_mode',
        'key_name_to_position', 'keyboard_hook', 'wm_integration_enabled', 'wm_lock', 'user_home',
        'mangowc_process', 'mangowc_thread'
    ]

    def __init__(self):
        try:
            # Initialize with error handling
            logger.info("Initializing keyboard controller...")
            
            # Get the correct user home directory
            self.user_home = get_user_home()
            logger.info(f"Using user home directory: {self.user_home}")
            
            # Load configuration first
            self.config = self.load_config()
            
            # Set log level based on config
            log_level = self.config.get('log_level', 'INFO').upper()
            numeric_level = getattr(logging, log_level, logging.INFO)
            
            # Update logger level
            for handler in logger.handlers:
                handler.setLevel(numeric_level)
            logger.setLevel(numeric_level)
            
            logger.info(f"Log level set to: {log_level}")
            
            # Start openrgb server
            self.start_rgb_server()

            time.sleep(5)

            self._string_cache = {}
            
            # Initialize OpenRGB client
            self.client = OpenRGBClient()
            logger.info("OpenRGB client created")
            
            # Find keyboard
            self.openrgb_keyboard = self.find_keyboard()
            
            if not self.openrgb_keyboard:
                raise RuntimeError("Openrgb keyboard not found")
            
            # Setup matrix zone
            self.setup_matrix_zone()
            
            # Build key name to position mapping
            self.key_name_to_position = self.build_key_name_mapping()
            logger.info(f"Built key name mapping with {len(self.key_name_to_position)} keys")
            
            # Parse key positions
            self.key_positions = self.parse_key_positions()
            logger.info(f"Loaded key positions for: {', '.join(self.key_positions.keys())}")
            
            # Get window manager type from config
            self.wm_type = self.config.get('window_manager', 'i3').lower()  # Default to i3
            if self.wm_type not in ['sway', 'i3', 'hyprland', 'mangowc']:
                logger.warning(f"Invalid window manager '{self.wm_type}'. Defaulting to 'i3'")
                self.wm_type = 'i3'
                
            logger.info(f"Using window manager: {self.wm_type}")
            
            # Initialize other components
            self.pressed_keys = deque()  # Track keys in press order
            self.colors_lock = threading.Lock()
            self.colors = self.load_colors()
            self.key_listener = None
            self.wm_thread = None
            self.pywal_updated = False
            self.config_updated = False
            self.pywal_watchdog_observer = None
            self.config_watchdog_observer = None
            self.current_mode = "base"
            self.previous_mode = "base"
            
            # Initialize mangowc attributes
            self.mangowc_process = None
            self.mangowc_thread = None
            
            # Define modifier keys
            self.modifier_keys = {
                'super': ['windows', 'cmd', 'super'],
                'shift': ['shift'],
                'alt': ['alt', 'alt gr'],
                'ctrl': ['ctrl', 'control']
            }
            
            # Check if workspace integration is needed
            self.wm_integration_enabled = self.config.get('workspaces', False) or self.needs_wm_integration()
            logger.info(f"Workspace integration: {'ENABLED' if self.wm_integration_enabled else 'DISABLED'}")
            
            # Create lock only if workspace integration is enabled
            if self.wm_integration_enabled:
                self.wm_lock = threading.Lock()
            else:
                self.wm_lock = None
            
            # Ensure base mode is defined
            if 'modes' not in self.config:
                self.config['modes'] = {}
            if 'base' not in self.config['modes']:
                self.config['modes']['base'] = {'rules': [{'keys': ['all'], 'color': '(0,255,0)'}]}
            
            # Track current state for optimization
            self.current_key_states = {}
            self.need_redraw = False
            self.last_non_empty_workspaces = set()
            
            # Set up keyboard hook
            self.keyboard_hook = None
            
            logger.info("Keyboard controller initialized successfully")
            
        except Exception as e:
            logger.error(f"Initialization failed: {e}")
            logger.error(traceback.format_exc())
            raise

    def start_rgb_server(self):
        logger.info("Starting openrgb server")

        openrgb_executable_path = "/usr/bin/openrgb"
        
        try:
            subprocess.Popen([openrgb_executable_path, "--server"])
        except Exception as e:
            logger.info(f"Failed to start openrgb server: {e}")
            raise

    def build_key_name_mapping(self) -> Dict[str, Tuple[int, int]]:
        """Build a mapping from key names to (row, col) positions"""
        key_name_map = {}
        
        # Iterate through the matrix to get key names
        for row in range(self.rows):
            for col in range(self.cols):
                try:
                    if (row, col) in self.matrix_map_dict:
                        led_index = self.matrix_map_dict[(row, col)]
                        led_name = self.matrix_zone.leds[led_index].name
                        
                        # Remove "Key: " prefix if present
                        if led_name.startswith("Key: "):
                            key_name = led_name[5:].strip().lower()
                        else:
                            key_name = led_name.strip().lower()
                        
                        # Add to mapping
                        key_name_map[key_name] = (row, col)
                        logger.debug(f"Mapped key '{key_name}' to position ({row}, {col})")
                except Exception as e:
                    logger.warning(f"Error mapping key at position ({row}, {col}): {e}")
        
        logger.info(f"Built key name mapping with {len(key_name_map)} keys")
        return key_name_map

    def setup_matrix_zone(self):
        """Find and setup the matrix zone"""
        self.matrix_zone = None
        
        # Look for a zone with matrix mapping
        for zone in self.openrgb_keyboard.zones:
            if hasattr(zone, 'matrix_map') and zone.matrix_map:
                self.matrix_zone = zone
                logger.info(f"Found matrix zone: {zone.name}")
                break
        
        if not self.matrix_zone:
            logger.error("No matrix zone found on device")
            raise RuntimeError("Keyboard doesn't have a matrix zone")
        
        # Handle different matrix_map representations
        if isinstance(self.matrix_zone.matrix_map, list):
            # Matrix map is a 2D list
            logger.info("Matrix map is a 2D list")
            self.rows = len(self.matrix_zone.matrix_map)
            self.cols = len(self.matrix_zone.matrix_map[0]) if self.rows > 0 else 0
            
            # Create a mapping from (row, col) to LED index
            self.matrix_map_dict = {}
            for row_idx, row in enumerate(self.matrix_zone.matrix_map):
                for col_idx, led_index in enumerate(row):
                    # Only add valid LED indices (not None)
                    if led_index is not None:
                        self.matrix_map_dict[(row_idx, col_idx)] = led_index
                    else:
                        logger.warning(f"None value found at position ({row_idx}, {col_idx})")
        
        logger.info(f"Keyboard matrix dimensions: {self.rows} rows x {self.cols} cols")
        logger.info(f"Valid key mappings: {len(self.matrix_map_dict)} positions")

    def get_cached_string(self, s):
        """Get a cached version of a string to avoid duplication"""
        if s not in self._string_cache:
            self._string_cache[s] = s
        return self._string_cache[s]

    def needs_wm_integration(self) -> bool:
        """Check if any rules require workspace information"""
        for mode_name, mode_config in self.config.get('modes', {}).items():
            for rule in mode_config.get('rules', []):
                if rule.get('condition') == 'non_empty_workspaces':
                    return True
        return False

    def load_config(self) -> Dict[str, Any]:
        """Load YAML configuration from script directory"""
        try:
            # Get config file
            config_dir = os.path.join(self.user_home, '.config', 'openrgb-keyboard-highlighter')
            config_path = os.path.join(config_dir, 'config.yaml')
            logger.info(f"Loading config from: {config_path}")
            
            if not os.path.exists(config_path):
                logger.info("Config file not found, using default configuration")
                return {
                    'pywal': True,
                    'workspaces': False,
                    'key_positions': {},
                    'log_level': 'INFO',  # Default log level
                    'modes': {
                        'base': {
                            'rules': [
                                {'keys': ['all'], 'color': '(0,255,0)'}
                            ]
                        }
                    }
                }
            
            with open(config_path, 'r') as f:
                config = yaml.safe_load(f)
                
                # Set defaults if not present
                config.setdefault('pywal', False)
                config.setdefault('workspaces', False)
                config.setdefault('log_level', 'INFO')  # Default log level
                
                logger.info("Config loaded successfully")
                return config
                
        except Exception as e:
            logger.error(f"Error loading config: {e}")
            logger.error(traceback.format_exc())
            return {}

    def parse_key_positions(self) -> Dict[str, List[Tuple[int, int]]]:
        """Parse key positions from config, with memory optimization"""
        positions = {}
        
        # Create 'all' key group using actual keyboard dimensions
        positions['all'] = [(r, c) for r in range(self.rows) for c in range(self.cols)]
        
        # Load positions from config
        if 'key_positions' in self.config:
            for key, value in self.config['key_positions'].items():
                try:
                    # Intern the key name to reduce duplication
                    interned_key = sys.intern(key)
                    
                    if isinstance(value, list):
                        # Convert all elements to (int, int)
                        converted = []
                        for item in value:
                            if isinstance(item, (list, tuple)) and len(item) == 2:
                                converted.append((int(item[0]), int(item[1])))
                            elif isinstance(item, str):
                                # Handle key names
                                normalized_name = item.strip().lower()
                                if normalized_name in self.key_name_to_position:
                                    converted.append(self.key_name_to_position[normalized_name])
                                elif item.startswith('(') and item.endswith(')'):
                                    # Safely parse string tuple
                                    try:
                                        # Remove parentheses and split
                                        stripped = item.strip()[1:-1]
                                        parts = stripped.split(',')
                                        if len(parts) == 2:
                                            row = int(parts[0].strip())
                                            col = int(parts[1].strip())
                                            converted.append((row, col))
                                        else:
                                            logger.warning(f"Invalid tuple format for key '{interned_key}': {item}")
                                    except ValueError as e:
                                        logger.warning(f"Error parsing position '{item}' for key '{interned_key}': {e}")
                                else:
                                    logger.warning(f"Unknown key name or invalid format for key '{interned_key}': {item}")
                            else:
                                logger.warning(f"Invalid position format for key '{interned_key}': {item}")
                        positions[interned_key] = converted
                    elif isinstance(value, (tuple, list)) and len(value) == 2:
                        # Single position
                        positions[interned_key] = [(int(value[0]), int(value[1]))]
                    elif isinstance(value, str):
                        # Handle key names
                        normalized_name = value.strip().lower()
                        if normalized_name in self.key_name_to_position:
                            positions[interned_key] = [self.key_name_to_position[normalized_name]]
                        elif value.startswith('(') and value.endswith(')'):
                            # Safely parse string tuple
                            try:
                                # Remove parentheses and split
                                stripped = value.strip()[1:-1]
                                parts = stripped.split(',')
                                if len(parts) == 2:
                                    row = int(parts[0].strip())
                                    col = int(parts[1].strip())
                                    positions[interned_key] = [(row, col)]
                                else:
                                    logger.warning(f"Invalid tuple format for key '{interned_key}': {value}")
                            except ValueError as e:
                                logger.warning(f"Error parsing position '{value}' for key '{interned_key}': {e}")
                        else:
                            logger.warning(f"Unknown key name or invalid format for key '{interned_key}': {value}")
                    else:
                        logger.warning(f"Invalid position format for key '{interned_key}': {value}")
                        positions[interned_key] = []
                except Exception as e:
                    logger.warning(f"Error parsing position for key '{key}': {e}")
                    positions[sys.intern(key)] = []
        
        # Add default positions for essential keys as integers
        defaults = {
            'super': [(5, 1)],
            'enter': [(3, 13)],
            'numbers': [(1,1), (1,2), (1,3), (1,4), (1,5), (1,6), (1,7), (1,8), (1,9), (1,10)],
            'arrows': [(5,14), (5,15), (5,16), (4,15)],
            'shift': [(4,0)],
            'alt': [(5,2)],
            'ctrl': [(5,0)],
            'q': [(2,1)],
            'd': [(3,3)],
            'x': [(4,3)],
            'z': [(4,2)],
            'space': [(5,7)],
            'tab': [(2,0)],
            'esc': [(1,0)],
            'backspace': [(1,15)],
        }
        
        for key, pos_list in defaults.items():
            if key not in positions:
                # Convert to list of integer tuples and intern the key
                interned_key = sys.intern(key)
                positions[interned_key] = [(int(r), int(c)) for r, c in pos_list]
                logger.info(f"Added default position for key '{interned_key}'")
        
        # Ensure all positions are integers
        for key in list(positions.keys()):
            new_list = []
            for pos in positions[key]:
                if isinstance(pos, (tuple, list)) and len(pos) == 2:
                    new_list.append((int(pos[0]), int(pos[1])))
            positions[key] = new_list
        
        return positions

    def find_keyboard(self):
        """Find keyboard using OpenRGB"""
        logger.info("Searching for keyboards with OpenRGB...")
        
        for device in self.client.devices:
            logger.debug(f"Checking device: {device.name} (Type: {device.type})")
            
            # Look for keyboard devices
            if device.type == DeviceType.KEYBOARD:
                logger.info(f"Using keyboard: {device.name}")
                return device
        
        logger.warning("No suitable keyboard found with OpenRGB")
        return None

    def load_colors(self) -> List[Tuple[int, int, int]]:
        """Load colors from pywal or use defaults"""
        if self.config.get('pywal', True):
            wal_path = os.path.join(self.user_home, '.cache', 'wal', 'colors')
            colors = self.read_wal_colors(wal_path)
            if colors:
                logger.info(f"Loaded {len(colors)} colors from pywal")
                return colors
            else:
                logger.info("Using fallback colors")
                return [
                    (55, 59, 67),    # Background
                    (171, 178, 191),  # Foreground
                    (191, 97, 106),   # Red
                    (163, 190, 140),  # Green
                    (224, 175, 104),  # Yellow
                    (129, 162, 190),  # Blue
                    (180, 142, 173),  # Magenta
                    (139, 213, 202),  # Cyan
                    (92, 99, 112)     # Light gray
                ]
        else:
            logger.info("Pywal disabled, using default colors")
            return [
                (100, 100, 100),  # Default color
                (200, 200, 200)   # Highlight color
            ]

    def read_wal_colors(self, file_path: str) -> List[Tuple[int, int, int]]:
        """Read colors from pywal cache file"""
        try:
            rgb_colors = []
            if not os.path.exists(file_path):
                logger.warning(f"Wal colors file not found at {file_path}")
                return []
                
            with open(file_path, 'r') as file:
                for line in file:
                    cleaned = line.strip()
                    if not cleaned:
                        continue
                    hex_color = cleaned.lstrip('#').strip()
                    if len(hex_color) == 6:
                        r = int(hex_color[0:2], 16)
                        g = int(hex_color[2:4], 16)
                        b = int(hex_color[4:6], 16)
                        rgb_colors.append((r, g, b))
            return rgb_colors
        except Exception as e:
            logger.error(f"Error reading wal colors: {e}")
            return []

    def resolve_color(self, color_spec: Any) -> Tuple[int, int, int]:
        """Convert color specification to RGB tuple"""
        try:
            # Handle RGB list
            if isinstance(color_spec, list) and len(color_spec) == 3:
                return tuple(color_spec)
            
            # Handle string specifications
            if isinstance(color_spec, str):
                # Handle color[n] specification
                match = re.match(r'color\[(\d+)\]', color_spec)
                if match:
                    idx = int(match.group(1))
                    if idx < len(self.colors):
                        return self.colors[idx]
                
                # Handle hex colors
                elif color_spec.startswith('#'):
                    hex_color = color_spec[1:]
                    if len(hex_color) == 6:
                        r = int(hex_color[0:2], 16)
                        g = int(hex_color[2:4], 16)
                        b = int(hex_color[4:6], 16)
                        return (r, g, b)
        except Exception as e:
            logger.error(f"Error resolving color {color_spec}: {e}")
        
        return (0, 0, 0)  # Default to black

    def get_hypr_user(self):
        try:
            result = subprocess.run(
                ["pgrep", "-u", "1000", "-a", "Hyprland"],  # UID 1000 is common for the first user
                capture_output=True, text=True
            )
            if result.returncode == 0 and result.stdout:
                # Example output: 1234 Hyprland
                for line in result.stdout.splitlines():
                    parts = line.strip().split()
                    pid = parts[0]
                    # Get user from PID
                    user_result = subprocess.run(
                        ["ps", "-o", "user=", "-p", pid],
                        capture_output=True, text=True
                    )
                    user = user_result.stdout.strip()
                    return user
            else:
                # Fallback: find the user from loginctl
                result = subprocess.run(["loginctl", "list-sessions"], capture_output=True, text=True)
                for line in result.stdout.splitlines():
                    if "seat0" in line and "tty" in line:
                        session_id = line.split()[0]
                        user_result = subprocess.run(
                            ["loginctl", "show-session", session_id, "-p", "Name"],
                            capture_output=True, text=True
                        )
                        return user_result.stdout.strip().split("=")[1]
        except Exception:
            pass
        return None

    def get_hyprland_signature_for_user(self, user):
        try:
            # Get the PID of Hyprland for that user
            result = subprocess.run(
                ["pgrep", "-u", user, "Hyprland"],
                capture_output=True, text=True
            )
            pid = result.stdout.strip().split("\n")[0]

            with open(f"/proc/{pid}/environ", "rb") as f:
                env = f.read().decode().split("\0")
                for var in env:
                    if var.startswith("HYPRLAND_INSTANCE_SIGNATURE="):
                        return var.split("=", 1)[1]
        except Exception:
            pass
        return None

    def get_hyprland_workspaces(self):
        """Get list of non-empty workspaces from Hyprland"""
        try:
            user = os.environ.get('OPENRGB_USER')

            # Use hyprctl to get workspace info
            result = subprocess.run(
                ['su', f'{user}', '-c' ,'hyprctl --instance 0 workspaces -j'],
                capture_output=True,
                text=True,
                timeout=1.0
            )
            workspaces = json.loads(result.stdout)
            
            non_empty = []
            for ws in workspaces:
                if ws['windows'] > 0:
                    # Only consider workspaces with IDs 1-10 for keyboard highlighting
                    if 1 <= ws['id'] <= 10:
                        non_empty.append(str(ws['id']))
            return non_empty
        except Exception as e:
            logger.error(f"Error getting Hyprland workspaces: {e}")
            return []

    def get_i3_or_sway_workspaces(self):
        """Get list of non-empty workspaces from i3/sway"""
        try:
            i3 = i3ipc.Connection()
            workspaces = i3.get_workspaces()
            tree = i3.get_tree()
            workspace_names = []

            for ws in workspaces:
                if ws.name == "__i3_scratch":
                    continue
                for container in tree.workspaces():
                    if container.name == ws.name:
                        if container.leaves():
                            workspace_names.append(ws.name)
                        break
            return workspace_names
        except Exception as e:
            logger.error(f"Error getting i3/sway workspaces: {e}")
            return []

    def get_mangowc_workspaces(self):
        """Get list of non-empty workspaces from mangowc/mmsg -g"""
        try:
            user = os.environ.get('OPENRGB_USER')
            if not user:
                logger.error("OPENRGB_USER environment variable not set")
                return []
            
            # Get user info
            try:
                user_info = pwd.getpwnam(user)
                user_uid = user_info.pw_uid
            except Exception as e:
                logger.error(f"Error getting user info: {e}")
                return []
            
            # Run mmsg directly (as root, but with user's environment)
            result = subprocess.run(
                [
                    'su', '-', user, '-c',
                    'XDG_RUNTIME_DIR=/run/user/{uid} WAYLAND_DISPLAY=wayland-0 mmsg -g'
                    .format(uid=user_uid)
                ],
                capture_output=True,
                text=True,
                timeout=2.0
            )

            if result.returncode == 0:
                lines = result.stdout.strip().split('\n')
                workspaces = self.parse_mmsg_output(lines)
                logger.debug(f"Parsed {len(workspaces)} workspaces from mmsg -g output")
                return workspaces
            else:
                logger.error(f"mmsg -g command failed with return code {result.returncode}")
                if result.stderr:
                    logger.error(f"stderr: {result.stderr}")
                return []
                    
        except FileNotFoundError:
            logger.error("mmsg command not found. Is mangoWC installed?")
            return []
        except subprocess.TimeoutExpired:
            logger.error("mmsg -g command timed out")
            return []
        except Exception as e:
            logger.error(f"Error getting mangowc workspaces: {e}")
            logger.error(traceback.format_exc())
            return []

    def parse_mmsg_output(self, lines: List[str]) -> List[str]:
        """Parse mmsg -g output to extract occupied tags/workspaces"""
        occupied_workspaces = []
        
        # First pass: look for tag lines
        for line in lines:
            line = line.strip()
            if "tag" in line and line.startswith("HDMI"):
                parts = line.split()
                if len(parts) >= 6:
                    try:
                        tag_num = parts[2]  # The tag number (1-9)
                        windows_count = int(parts[4])  # Number of windows
                        
                        if windows_count > 0:
                            occupied_workspaces.append(tag_num)
                            logger.debug(f"Tag {tag_num} has {windows_count} windows")
                    except (IndexError, ValueError) as e:
                        logger.debug(f"Error parsing mmsg line '{line}': {e}")
                    except:
                        pass
        
        # Deduplicate and sort
        result = sorted(list(set(occupied_workspaces)))
        logger.debug(f"Found occupied workspaces: {result}")
        return result

    def find_non_empty_workspaces(self):
        """Get list of non-empty workspaces from the configured WM"""
        if not self.wm_integration_enabled:
            return []
            
        try:
            if (self.wm_type == 'i3' or self.wm_type == 'sway') and I3_AVAILABLE:
                return self.get_i3_or_sway_workspaces()
            elif self.wm_type == 'hyprland':
                return self.get_hyprland_workspaces()
            elif self.wm_type == 'mangowc':
                return self.get_mangowc_workspaces()
        except Exception as e:
            logger.error(f"Error getting workspaces: {e}")
        return []

    def update_workspaces(self):
        """Update workspace status (only if integration enabled)"""
        if not self.wm_integration_enabled:
            return
            
        if self.wm_lock:
            with self.wm_lock:
                try:
                    current_workspaces = set(self.find_non_empty_workspaces())
                    # Only mark for redraw if workspaces have changed
                    if current_workspaces != self.last_non_empty_workspaces:
                        self.last_non_empty_workspaces = current_workspaces
                        self.need_redraw = True
                        self.update_lighting()
                        logger.info(f"Workspaces changed: {current_workspaces}")
                except Exception as e:
                    logger.error(f"Error updating workspaces: {e}")
        else:
            try:
                current_workspaces = set(self.find_non_empty_workspaces())
                # Only mark for redraw if workspaces have changed
                if current_workspaces != self.last_non_empty_workspaces:
                    self.last_non_empty_workspaces = current_workspaces
                    self.need_redraw = True
                    self.update_lighting()
                    logger.info(f"Workspaces changed: {current_workspaces}")
            except Exception as e:
                logger.error(f"Error updating workspaces: {e}")

    def reload_config(self):
        """Reload configuration from file"""
        with self.colors_lock:
            try:
                self.config = self.load_config()
                # Rebuild key name mapping in case keyboard changed
                self.key_name_to_position = self.build_key_name_mapping()
                self.key_positions = self.parse_key_positions()
                self.colors = self.load_colors()
                
                # Update log level if changed
                log_level = self.config.get('log_level', 'INFO').upper()
                numeric_level = getattr(logging, log_level, logging.INFO)
                
                # Update logger level
                for handler in logger.handlers:
                    handler.setLevel(numeric_level)
                logger.setLevel(numeric_level)
                logger.info(f"Log level updated to: {log_level}")
                
                # Re-evaluate workspace requirement
                self.wm_type = self.config.get('window_manager', 'i3').lower()
                self.wm_integration_enabled = self.config.get('workspaces', False) or self.needs_wm_integration()
                logger.info(f"Workspace integration: {'ENABLED' if self.wm_integration_enabled else 'DISABLED'}")
                logger.info("Configuration reloaded")

                self.config_updated = False
                # Force redraw after config reload
                self.need_redraw = True
                # Update lighting after reload
                self.update_lighting()
            except Exception as error:
                logger.error(f"Error reloading config: {error}")

    def get_keys_positions(self, key_spec: Any) -> List[Tuple[int, int]]:
        """Get positions for a key or key group"""
        try:
            if isinstance(key_spec, str):
                # Check if it's a key name
                normalized_name = key_spec.strip().lower()
                if normalized_name in self.key_name_to_position:
                    return [self.key_name_to_position[normalized_name]]
                # Otherwise, check if it's a predefined group
                return self.key_positions.get(key_spec, [])
            elif isinstance(key_spec, list):
                positions = []
                for k in key_spec:
                    positions.extend(self.get_keys_positions(k))
                return positions
        except Exception as e:
            logger.error(f"Error getting positions for {key_spec}: {e}")
        return []

    def apply_rule(self, rule: Dict[str, Any], desired_state: Dict[Tuple[int, int], Tuple[int, int, int]]):
        """Apply a lighting rule to the desired state"""
        try:
            # Get key positions
            keys = rule.get('keys', [])
            positions = self.get_keys_positions(keys)
            if not positions:
                logger.warning(f"No positions found for keys: {keys}")
                return
            
            # Handle per-key colors
            if 'colors' in rule:
                logger.info(f"Applying per-key colors for {keys}")
                colors = [self.resolve_color(c) for c in rule['colors']]
                for i, pos in enumerate(positions):
                    try:
                        row = int(pos[0])
                        col = int(pos[1])
                        if i < len(colors):
                            desired_state[(row, col)] = colors[i]
                    except (ValueError, TypeError):
                        continue
            
            # Handle conditional rules
            condition = rule.get('condition')
            if condition == 'non_empty_workspaces':
                # Skip if workspace integration not enabled
                if not self.wm_integration_enabled:
                    logger.info("Skipping workspace condition - integration disabled")
                    return
                    
                value = rule.get('value')
                color = self.resolve_color(rule.get('color'))
                logger.info(f"Applying condition for {keys}: non_empty={value}")
                
                # Only apply to number keys
                if keys == ['numbers']:
                    for i, pos in enumerate(positions):
                        try:
                            row = int(pos[0])
                            col = int(pos[1])
                            workspace_num = str(i + 1)
                            if (workspace_num in self.last_non_empty_workspaces) == value:
                                desired_state[(row, col)] = color
                        except (ValueError, TypeError):
                            continue
                return
            
            # Handle simple color rule
            if 'color' in rule:
                color = self.resolve_color(rule['color'])
                logger.debug(f"Setting {keys} to {color}")
                for pos in positions:
                    try:
                        row = int(pos[0])
                        col = int(pos[1])
                        desired_state[(row, col)] = color
                    except (ValueError, TypeError):
                        continue
        except Exception as e:
            logger.error(f"Error applying rule: {e}")
            logger.error(traceback.format_exc())

    def normalize_key_str(self, key_name: str) -> str:
        """Normalize key name string with memory optimization"""
        name = key_name.lower()
        
        # Define a set of common keys for interning
        common_keys = {
            'super', 'shift', 'alt', 'ctrl', 'enter', 'space', 'tab', 
            'esc', 'escape', 'backspace', 'up', 'down', 'left', 'right',
            'windows', 'cmd', 'control', 'alt gr', '`', '~', '!', '@',
            '#', '$', '%', '^', '&', '*', '(', ')', '-', '_', '=', '+',
            '[', ']', '{', '}', '\\', '|', ';', ':', "'", '"', ',', '<',
            '.', '>', '/', '?', 'backtick', 'tilde', 'exclamation', 'at',
            'hash', 'dollar', 'percent', 'caret', 'ampersand', 'asterisk',
            'paren_left', 'paren_right', 'minus', 'underscore', 'equal',
            'plus', 'bracket_left', 'bracket_right', 'brace_left', 'brace_right',
            'backslash', 'pipe', 'semicolon', 'colon', 'apostrophe', 'quote',
            'comma', 'less', 'period', 'greater', 'slash', 'question'
        }
        
        # Handle modifier keys
        for mod, aliases in self.modifier_keys.items():
            if name in aliases:
                return sys.intern(mod)
        
        # Handle special keys
        special_keys = {
            'enter': 'enter',
            'space': 'space',
            'tab': 'tab',
            'esc': 'esc',
            'escape': 'esc',
            'backspace': 'backspace',
            'up': 'up',
            'down': 'down',
            'left': 'left',
            'right': 'right',
            '`': 'backtick',
            '~': 'tilde',
            '!': 'exclamation',
            '@': 'at',
            '#': 'hash',
            '$': 'dollar',
            '%': 'percent',
            '^': 'caret',
            '&': 'ampersand',
            '*': 'asterisk',
            '(': 'paren_left',
            ')': 'paren_right',
            '-': 'minus',
            '_': 'underscore',
            '=': 'equal',
            '+': 'plus',
            '[': 'bracket_left',
            ']': 'bracket_right',
            '{': 'brace_left',
            '}': 'brace_right',
            '\\': 'backslash',
            '|': 'pipe',
            ';': 'semicolon',
            ':': 'colon',
            "'": 'apostrophe',
            '"': 'quote',
            ',': 'comma',
            '<': 'less',
            '.': 'period',
            '>': 'greater',
            '/': 'slash',
            '?': 'question'
        }
        
        # Handle number keys
        if name.isdigit():
            return sys.intern(name) if name in common_keys else name
        
        # Handle letter keys
        if len(name) == 1:
            normalized = name.lower()
            return sys.intern(normalized) if normalized in common_keys else normalized
        
        # Return special key if found, otherwise return original
        if name in special_keys:
            result = special_keys[name]
            return sys.intern(result) if result in common_keys else result
        
        # For any other key, intern if it's common
        return sys.intern(name) if name in common_keys else name

    def get_current_mode(self) -> str:
        """Determine current mode based on pressed keys with consistent ordering"""
        try:
            # Create a filtered list of only modifier keys that are currently pressed
            pressed_modifiers = [
                key for key in self.pressed_keys 
                if key in ['super', 'shift', 'alt', 'ctrl']
            ]
            
            # 1. Check full sequence of pressed keys (including non-modifiers)
            if self.pressed_keys:
                full_sequence = '_'.join(self.pressed_keys)
                if full_sequence in self.config.get('modes', {}):
                    logger.info(f"Active key sequence mode: {full_sequence}")
                    if self.previous_mode != full_sequence:
                        self.previous_mode = full_sequence
                        self.need_redraw = True
                    return full_sequence
            
            # 2. Check modifier-only sequence (only modifier keys in press order)
            if pressed_modifiers:
                mode_name = '_'.join(pressed_modifiers)
                if mode_name in self.config.get('modes', {}):
                    logger.info(f"Active modifier mode: {mode_name}")
                    if self.previous_mode != mode_name:
                        self.previous_mode = mode_name
                        self.need_redraw = True
                    return mode_name
            
            # Fallback to base mode if no special mode is active
            return 'base'
        except Exception as e:
            logger.error(f"Error determining current mode: {e}")
            return 'base'

    def update_lighting(self):
        """Update keyboard lighting based on current state - only redraw if needed"""
        try:
            # Create desired state (start with all black)
            desired_state = {}
            
            # Apply current mode with fallback
            current_mode = self.get_current_mode()
            mode_config = self.config.get('modes', {}).get(current_mode)
            
            # Fallback to base mode if current mode not defined
            if mode_config is None and current_mode != 'base':
                logger.info(f"Mode '{current_mode}' not defined, falling back to base")
                mode_config = self.config.get('modes', {}).get('base', {})
            
            # If still no config, use empty
            if mode_config is None:
                mode_config = {}
            
            logger.info(f"Applying lighting for mode: {current_mode}")
            
            # Apply all rules for the current mode to desired state
            for rule in mode_config.get('rules', []):
                self.apply_rule(rule, desired_state)
            
            # Check if any keys have changed
            needs_update = False
            for (row, col), color in desired_state.items():
                if self.current_key_states.get((row, col), (0, 0, 0)) != color:
                    needs_update = True
                    break
            
            # Only update if changes are detected
            if needs_update or self.need_redraw:
                # Clear keyboard (set all to black)
                for led_index in range(len(self.matrix_zone.colors)):
                    self.matrix_zone.colors[led_index] = RGBColor(0, 0, 0)
                
                # Apply desired state
                for (row, col), color in desired_state.items():
                    try:
                        # Convert row/col to matrix coordinates
                        if (row, col) in self.matrix_map_dict:
                            led_index = self.matrix_map_dict[(row, col)]
                            self.matrix_zone.colors[led_index] = RGBColor(*color)
                            self.current_key_states[(row, col)] = color
                        else:
                            # Log missing positions at debug level to avoid spam
                            logger.debug(f"No LED mapping for position ({row}, {col})")
                    except Exception as e:
                        logger.error(f"Error setting key at ({row}, {col}): {e}")
                
                # Draw changes
                self.matrix_zone.show(fast=True)
                logger.info("Keyboard redrawn due to changes")
                self.need_redraw = False
            else:
                logger.info("No changes detected, skipping redraw")
        except Exception as e:
            logger.error(f"Error updating lighting: {e}")
            logger.error(traceback.format_exc())

    def on_key_event(self, event):
        """Handle keyboard events directly"""
        try:
            if event.event_type == keyboard.KEY_DOWN:
                self.on_press_str(event.name)
            elif event.event_type == keyboard.KEY_UP:
                self.on_release_str(event.name)
        except Exception as e:
            logger.error(f"Error in keyboard event handler: {e}")

    def on_press_str(self, key_name: str):
        """Handle key press events from string"""
        try:
            key_identifier = self.normalize_key_str(key_name)
            
            logger.debug(f"KEY PRESS: {key_name} -> {key_identifier}")
            
            # Add to pressed keys if not already present
            if key_identifier not in self.pressed_keys:
                self.pressed_keys.append(key_identifier)
                logger.debug(f"Keys pressed: {list(self.pressed_keys)}")
            
            # Update lighting immediately on key press
            self.update_lighting()
            
            # Update workspaces when modifier state changes (only if integration enabled)
            if self.wm_integration_enabled and key_identifier in ['super', 'alt', 'shift', 'ctrl']:
                self.update_workspaces()
        except Exception as e:
            logger.error(f"Error in on_press: {e}")

    def on_release_str(self, key_name: str):
        """Handle key release events from string"""
        try:
            key_identifier = self.normalize_key_str(key_name)
            
            logger.debug(f"KEY RELEASE: {key_name} -> {key_identifier}")
            
            # Remove from pressed keys
            if key_identifier in self.pressed_keys:
                self.pressed_keys.remove(key_identifier)
                logger.debug(f"Keys pressed: {list(self.pressed_keys)}")
            
            # Update lighting immediately on key release
            self.current_mode = self.get_current_mode()
            self.update_lighting()
            
        except Exception as e:
            logger.error(f"Error in on_release: {e}")

    def listen_hyprland_events(self):
        """Listen for Hyprland workspace events"""
        try:
            # Get the Hyprland instance signature
            instance_sig = os.getenv('HYPRLAND_INSTANCE_SIGNATURE')
            if not instance_sig:
                logger.error("HYPRLAND_INSTANCE_SIGNATURE not set")
                return
                
            # Get XDG runtime directory
            xdg_runtime_dir = os.getenv('XDG_RUNTIME_DIR')
            if not xdg_runtime_dir:
                logger.error("XDG_RUNTIME_DIR not set, using fallback")
                xdg_runtime_dir = f"/run/user/{os.getuid()}"
                
            # Correct socket path using XDG_RUNTIME_DIR
            socket_path = os.path.join(xdg_runtime_dir, 'hypr', instance_sig, '.socket2.sock')
            
            if not os.path.exists(socket_path):
                logger.error(f"Hyprland socket not found at {socket_path}")
                return
                
            sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            sock.connect(socket_path)
            
            logger.info("Connected to Hyprland event socket")
                
            while True:
                # Check if we should stop
                if not self.wm_integration_enabled:
                    break
                    
                ready = select.select([sock], [], [], 1)
                if ready[0]:
                    data = sock.recv(4096)
                    if not data:
                        break
                        
                    event = data.decode().strip()
                    # Handle relevant events
                    if event.startswith(("workspace>>", "openwindow>>", "closewindow>>", "movewindow>>")):
                        logger.debug(f"Hyprland event: {event}")
                        self.update_workspaces()
                        self.update_lighting()
        except Exception as e:
            logger.error(f"Error in Hyprland listener: {e}")
        finally:
            try:
                sock.close()
            except:
                pass

    def start_wm_listener(self):
        """Listen for window manager events"""
        if not self.wm_integration_enabled:
            return
            
        try:
            if (self.wm_type == 'i3' or self.wm_type == 'sway') and I3_AVAILABLE:
                i3 = i3ipc.Connection()
                i3.on('window', self.on_wm_event)
                logger.info("Starting i3 event listener")
                i3.main()
            elif self.wm_type == 'hyprland':
                logger.info("Starting Hyprland event listener")
                self.listen_hyprland_events()
        except Exception as e:
            logger.error(f"Error in WM listener: {e}")

    def on_wm_event(self, i3, event):
        """Handle window manager events"""
        if not self.wm_integration_enabled:
            return
            
        try:
            if (self.wm_type == 'i3' or self.wm_type == 'sway'):
                if event.change in ['new', 'close', 'move']:
                    self.update_workspaces()
                    self.update_lighting()
        except Exception as e:
            logger.error(f"Error in WM event handler: {e}")

    def start_pywal_watcher(self):
        """Start watching pywal color file for changes"""
        pywal_path = os.path.join(self.user_home, '.cache', 'wal')
        if not os.path.exists(pywal_path):
            return
        
        pywal_event_handler = PywalFileHandler(self.handle_pywal_update)
        self.pywal_watchdog_observer = Observer()
        self.pywal_watchdog_observer.schedule(pywal_event_handler, pywal_path, recursive=False)
        self.pywal_watchdog_observer.start()
        logger.info(f"Started watching pywal colors at {pywal_path}")

    def start_config_watcher(self):
        """Start watching config file for changes"""
        config_path = os.path.join(self.user_home, '.config', 'openrgb-keyboard-highlighter')
        if not os.path.exists(config_path):
            os.makedirs(config_path, exist_ok=True)
            logger.info(f"Created config directory: {config_path}")
        
        config_event_handler = ConfigFileHandler(self.handle_config_update)
        self.config_watchdog_observer = Observer()
        self.config_watchdog_observer.schedule(config_event_handler, config_path, recursive=False)
        self.config_watchdog_observer.start()
        logger.info(f"Started watching config at {config_path}")

    def handle_pywal_update(self):
        """Called when pywal colors change - update lighting"""
        logger.info("Pywal colors updated - reloading")
        self.pywal_updated = True

    def handle_config_update(self):
        """Called when configs change - update lighting"""
        logger.info("Config updated - reloading")
        self.config_updated = True

    def reload_pywal_colors(self):
        """Reload colors and update lighting"""
        with self.colors_lock:
            self.colors = self.load_colors()
        self.pywal_updated = False
        # Force redraw after color reload
        self.need_redraw = True
        self.update_lighting()
        logger.info("Colors reloaded from pywal")

    def run(self):
        """Main application loop"""
        try:
            # Set up keyboard hook for direct keyboard access
            self.keyboard_hook = keyboard.hook(self.on_key_event)
            logger.info("Keyboard hook installed")
            
            if self.wm_integration_enabled:
                self.update_workspaces()
                
                # Start WM listener thread only if enabled
                self.wm_thread = threading.Thread(target=self.start_wm_listener, daemon=True)
                self.wm_thread.start()
                logger.info(f"{self.wm_type} listener started")
            
            # Start pywal file watcher if enabled
            if self.config.get('pywal', True):
                self.start_pywal_watcher()
                logger.info("Pywal file watcher started")

            self.start_config_watcher()
            logger.info("Config file watcher started")
            
            # Apply initial lighting
            self.update_lighting()
            
            # Main loop
            logger.info("Entering main loop (Press Ctrl+C to exit)")
            while True:
                # Check for pywal updates
                if self.pywal_updated:
                    self.reload_pywal_colors()
                # Check for config updates
                if self.config_updated:
                    self.reload_config()
                
                # Periodically update workspaces only if integration enabled
                if self.wm_integration_enabled:
                    self.update_workspaces()
                    
                # Small sleep to prevent CPU spinning
                time.sleep(0.1)
                
        except KeyboardInterrupt:
            logger.info("Exiting...")
            if self.keyboard_hook:
                keyboard.unhook(self.keyboard_hook)
            if self.pywal_watchdog_observer:
                self.pywal_watchdog_observer.stop()
                self.pywal_watchdog_observer.join()
            if self.config_watchdog_observer:
                self.config_watchdog_observer.stop()
                self.config_watchdog_observer.join()
            
            # Clean up mangowc process if running
            if hasattr(self, 'mangowc_process') and self.mangowc_process:
                try:
                    self.mangowc_process.terminate()
                    self.mangowc_process.wait(timeout=1)
                except:
                    try:
                        self.mangowc_process.kill()
                    except:
                        pass
            
            # Turn off keyboard lights
            try:
                for led_index in range(len(self.matrix_zone.colors)):
                    self.matrix_zone.colors[led_index] = RGBColor(0, 0, 0)
                self.matrix_zone.show(fast=True)
            except:
                pass
        except Exception as e:
            logger.error(f"Error in main loop: {e}")
            logger.error(traceback.format_exc())

if __name__ == "__main__":
    try:
        controller = KeyboardController()
        controller.run()
    except Exception as e:
        logger.critical(f"Critical error: {e}")
        logger.critical(traceback.format_exc())
